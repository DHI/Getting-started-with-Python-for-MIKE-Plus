# Homework {.unnumbered}

These exercises will guide you through a complete workflow: loading data from a common format (CSV), cleaning and preparing it using Pandas, visualizing it, and finally, converting it into a DFS0 file suitable for MIKE+ using MIKE IO.

**Exercise 1: Load, Inspect, and Prepare Rainfall Data from CSV**

This exercise focuses on ingesting external data into a familiar Pandas DataFrame structure, performing initial inspections, and basic preparations.

1.  First, ensure that `mikeio`, `pandas`, and `matplotlib` are installed in your Python environment. If you need a reminder on how to do this, please refer to the setup instructions in Module 1.
2.  Download the rainfall data CSV file. Click [here to download `rainfall_data.csv`](data/homework/rainfall_data.csv){download="rainfall_data.csv"} and save it into your project folder, perhaps in a `data/homework/` subdirectory.
3.  Now, load the `rainfall_data.csv` file into a Pandas DataFrame. You can use the `pd.read_csv()` function for this.

    ```{python}
    import pandas as pd
    
    # Assuming the file is in 'data/homework/rainfall_data.csv' relative to your script/notebook
    csv_filepath = "data/homework/rainfall_data.csv" 
    df = pd.read_csv(csv_filepath)
    ```

4.  Inspect the DataFrame to understand its structure and content:
    *   Display the first 5 rows using the `.head()` method. This gives you a quick look at the data.

        ```{python}
        df.head()
        ```

    *   Print summary information using the `.info()` method. This will show column data types and non-null counts.

        ```{python}
        df.info()
        ```

5.  The 'Timestamp' column currently likely holds strings but should represent time. Convert this column to datetime objects using `pd.to_datetime()`, and then set this 'Timestamp' column as the DataFrame's index using `df.set_index()`.

    ```{python}
    df['Timestamp'] = pd.to_datetime(df['Timestamp'])
    df = df.set_index('Timestamp')
    ```

6.  Re-check the DataFrame's structure using `.info()` again. Confirm that the index is now a `DatetimeIndex` and note the data type of the 'Rainfall_mm' column.

    ```{python}
    df.info()
    ```

7.  Use the `.describe()` method on the 'Rainfall_mm' column to get summary statistics. What are the mean, min, and max rainfall values? Do these values seem reasonable for hourly rainfall data?

    ```{python}
    df['Rainfall_mm'].describe()
    ```

**Exercise 2: Clean Data and Define MIKE IO Metadata**

Before converting to DFS0, data often needs cleaning. Additionally, MIKE IO requires specific metadata for proper interpretation of the data within MIKE software.

1.  Check if there are any missing values (NaNs) in the 'Rainfall_mm' column. The `.isnull().sum()` combination is very useful here.

    ```{python}
    df['Rainfall_mm'].isnull().sum()
    ```

2.  If missing values exist (the previous command would show a count greater than zero), impute them using linear interpolation. This is a common method for filling gaps in time series data. Apply the `.interpolate(method='linear')` method directly to the 'Rainfall_mm' column.
    *   After interpolation, verify that no missing values remain by running the check from step 1 again.

    ```{python}
    df['Rainfall_mm'] = df['Rainfall_mm'].interpolate(method='linear')
    df['Rainfall_mm'].isnull().sum()
    ```

3.  Identify the appropriate MIKE IO metadata for your rainfall data. This involves determining the item name, EUM Type, EUM Unit, and Data Value Type.

    *   **Item Name**: This will typically be the column name from your DataFrame. In this case, it's 'Rainfall_mm'.
    *   **EUM Type**: What is the DHI EUM Type for rainfall?
        *   Hint: You'll need to import `EUMType` from `mikeio.eum`. You can then explore its attributes to find a suitable type for rainfall (e.g., `mikeio.eum.EUMType.Rainfall`).
    *   **EUM Unit**: What is the DHI EUM Unit for rainfall measured in millimeters?
        *   Hint: Similar to EUM Type, import `EUMUnit` from `mikeio.eum` and find the unit for millimeters (e.g., `mikeio.eum.EUMUnit.mm`).
    *   **Data Value Type**: Given that the rainfall data represents the total amount that has fallen *within* each time step (e.g., the total mm in the hour ending at the timestamp), what `data_value_type` is most appropriate? Common options include 'Instantaneous', 'Accumulated', 'StepAccumulated', 'MeanStepBackward', 'MeanStepForward'.

        ::: {.callout-tip}
        'StepAccumulated' is often used for incremental rainfall totals recorded over a time step, like hourly rainfall.
        :::

**Exercise 3: Visualize Cleaned Rainfall Data and Save Plot**

Visualizing the data is a crucial step to ensure it looks as expected before further processing or file conversion.

1.  Using the cleaned Pandas DataFrame from Exercise 2 (after NaN imputation):
    *   Create a line plot of the 'Rainfall_mm' time series. The `.plot()` method on a Pandas Series makes this straightforward.

    ```{python}
    # Ensure matplotlib is available for plotting
    import matplotlib.pyplot as plt
    
    df['Rainfall_mm'].plot()
    ```

2.  Customize your plot to make it more informative:
    *   Add a title (e.g., "Hourly Rainfall Data").
    *   Set an appropriate label for the y-axis (e.g., "Rainfall (mm)").
    *   Ensure the x-axis (time) is clearly labeled (Pandas often does this well by default if the index is a DatetimeIndex).
    *   Hint: You can use `plt.title()`, `plt.ylabel()`, `plt.xlabel()` from `matplotlib.pyplot` *after* calling `df.plot()`, or pass arguments like `title` and `ylabel` directly to the `.plot()` method.

    ```{python}
    df['Rainfall_mm'].plot(title='Hourly Rainfall Data', ylabel='Rainfall (mm)', xlabel='Time')
    plt.show() # Ensures the plot is displayed
    ```

3.  Save the plot as a PNG file named `rainfall_timeseries.png`.
    *   Hint: If using `matplotlib.pyplot` (often imported as `plt`), use `plt.savefig()`. Remember to call this *before* `plt.show()` if you are in a script, or ensure the plot object is correctly handled in a Jupyter environment.

    ```{python}
    # Assuming the plot from the previous step is still the active one
    # For this example, we'll replot and save
    df['Rainfall_mm'].plot(title='Hourly Rainfall Data', ylabel='Rainfall (mm)', xlabel='Time')
    plt.savefig('rainfall_timeseries.png')
    plt.close() # Closes the plot figure to free up memory
    ```

**Exercise 4: Create DFS0 File with MIKE IO**

This exercise converts your prepared Pandas DataFrame into a MIKE IO `Dataset` object with the correct metadata, and then writes it to a DFS0 file.

1.  Import `ItemInfo` from `mikeio`. You'll also need `EUMType` and `EUMUnit` if you haven't imported them already.

    ```{python}
    from mikeio import ItemInfo
    from mikeio.eum import EUMType, EUMUnit
    import mikeio # For mikeio.from_pandas
    ```

2.  Create an `ItemInfo` object for your rainfall data series. Use 'Rainfall_mm' for the `name` argument, and the `EUMType`, `EUMUnit`, and `data_value_type` you identified in Exercise 2. For example, `EUMType.Rainfall`, `EUMUnit.mm`, and `data_value_type="StepAccumulated"`.

    ```{python}
    item_rainfall = ItemInfo(
        name='Rainfall_mm', 
        itemtype=EUMType.Rainfall, 
        unit=EUMUnit.mm, 
        data_value_type='StepAccumulated'
    )
    print(item_rainfall)
    ```

3.  Convert your cleaned Pandas DataFrame (from Exercise 2) to a `mikeio.Dataset` using `mikeio.from_pandas()`.
    *   Pass your DataFrame as the first argument.
    *   Pass a Python list containing your single `ItemInfo` object (e.g., `[item_rainfall]`) to the `items` argument.

    ```{python}
    ds = mikeio.from_pandas(df, items=[item_rainfall])
    ```

4.  Inspect the created `Dataset` by printing its `items` attribute (e.g., `print(ds.items)`). Verify that the name, type, unit, and data value type match what you intended.

    ```{python}
    print(ds.items)
    ```

5.  Save the `Dataset` to a DFS0 file named `rainfall_output.dfs0` using the `.to_dfs()` method of the `Dataset` object.

    ```{python}
    ds.to_dfs("rainfall_output.dfs0")
    ```

**Exercise 5: Verify the Created DFS0 File**

It's good practice to verify that the file you created is correct and contains the data as expected.

1.  Read the `rainfall_output.dfs0` file you just created back into a new `mikeio.Dataset` object using `mikeio.read()`.

    ```{python}
    ds_verify = mikeio.read("rainfall_output.dfs0")
    ```

2.  Inspect the `items` attribute of this new `Dataset`. Does the metadata look correct and match what you specified?

    ```{python}
    print(ds_verify.items)
    ```

3.  Convert this new `Dataset` object back into a Pandas DataFrame using its `.to_dataframe()` method.

    ```{python}
    df_verify = ds_verify.to_dataframe()
    ```

4.  Display the `head()` and `info()` of this new DataFrame. Compare it to the DataFrame you had before saving to DFS0 (from Exercise 2 or 3, after cleaning). Are they consistent in terms of data, index, and column names?

    ```{python}
    df_verify.head()
    ```

    ```{python}
    df_verify.info()
    ```

5.  (Optional) Use the `.describe()` method on the rainfall column of this newly loaded DataFrame. Do the statistics match those from Exercise 1, step 7 (or rather, the statistics of the cleaned data before saving)?

    ```{python}
    df_verify['Rainfall_mm'].describe()
    ```

**Practice Exercises (optional)**

For further practice, consider exploring the following:
*   Try loading a DFS0 file with multiple items.
*   Experiment with different resampling techniques on your rainfall data (e.g., calculating daily totals).
*   Explore other `data_value_type` options when creating `ItemInfo` and observe how MIKE+ might interpret them differently (you might need to check MIKE+ documentation for this).