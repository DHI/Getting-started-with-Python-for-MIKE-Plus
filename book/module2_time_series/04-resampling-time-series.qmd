# Resampling Time Series Data

Resampling is a frequent operation in time series analysis. It involves changing the frequency of your time series data. This can mean either **downsampling**, where you aggregate data from a higher frequency to a lower one (like converting 10-minute data to hourly or daily data), or **upsampling**, where you increase the frequency (such as converting daily data to hourly, which usually requires interpolation to fill in the new time points). `pandas` offers robust tools for these tasks.

## Why Resample Time Series Data?

You might need to resample your time series data for several practical reasons:

*   **Matching Frequencies:** Often, datasets you want to compare or combine are recorded at different time resolutions. Resampling helps align them.
*   **Aggregation:** To calculate summary statistics over specific periods—for instance, total daily rainfall from hourly records or average monthly temperature from daily figures.
*   **Noise Reduction:** Downsampling can smooth out noisy, high-frequency data, making underlying trends more apparent.
*   **Model Requirements:** Some hydrological or environmental models require input data at a specific time step.

## Using `pandas.DataFrame.resample()`

The primary method for resampling in `pandas` is `.resample()`, which you call on a DataFrame or Series that has a `DatetimeIndex`. The process typically involves two steps:

1.  **Specify the Target Frequency:** You provide a rule or offset string that defines the new frequency. Common examples include `'D'` for daily, `'H'` for hourly, or `'15T'` for 15-minute intervals.
2.  **Apply an Aggregation or Interpolation Method:** After specifying the new frequency, you must tell `pandas` how to calculate the values for these new time points. For downsampling, this is usually an aggregation method like `.mean()`, `.sum()`, `.min()`, or `.max()`. For upsampling, you might use `.interpolate()` or a fill method like `.ffill()` (forward fill) or `.bfill()` (backward fill).

Let's assume you have a `pandas` DataFrame named `df`, loaded from a file like "data/sample.dfs0", which has a `DatetimeIndex` and contains numerical data columns such as 'Value1' and 'Value2'.

Here's how you can downsample data, for example, to calculate daily means:

```{python}
# Assume df is your DataFrame with high-frequency data in 'Value1'
# (e.g., 10-minute or hourly readings)
daily_means = df[['Value1']].resample('D').mean()
daily_means.head()
```

Similarly, to calculate hourly sums from finer-grained data:

```{python}
# Using the same DataFrame df, with data in 'Value2'
hourly_sums = df[['Value2']].resample('H').sum()
hourly_sums.head()
```

Upsampling involves creating new time points between existing ones. For instance, if you have a DataFrame `daily_data` with daily values and want to convert it to an hourly frequency using forward fill:

```{python}
# Assume daily_data is a DataFrame with daily values for 'Value1'
# (e.g., daily_data = df[['Value1']].resample('D').mean() )
hourly_from_daily = daily_data.resample('H').ffill()
hourly_from_daily.head()
```

::: {.callout-tip}
## Ensure `DatetimeIndex`
For the `.resample()` method to work correctly, your DataFrame's index **must** be a `DatetimeIndex`. When you load `dfs0` data using `mikeio` and convert it to a DataFrame with `to_dataframe()`, this is typically handled for you. If you construct a DataFrame from other sources, you might need to convert a column to a `DatetimeIndex` using `pd.to_datetime()` and then set it as the index with `df.set_index()`.
:::

For a comprehensive list of resampling rules (offset aliases) and available aggregation or interpolation methods, refer to the official [Pandas `resample()` documentation](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.resample.html).

## Video - Example: Resampling Time Series Data (5-10 min)
*   Show a `pandas` DataFrame with a high-frequency time series (e.g., 10-minute data).
*   Demonstrate downsampling to hourly data using `.resample('H').sum()`.
*   Show the resulting DataFrame, highlighting the change in frequency and values.
*   Optionally, demonstrate upsampling with a simple fill method like `.ffill()`.

{{< video YOUR_VIDEO_URL_HERE >}}