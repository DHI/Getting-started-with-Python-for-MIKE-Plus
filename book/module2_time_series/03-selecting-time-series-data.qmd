# Selecting Time Series Data

Once your `dfs0` data is loaded, either as a `mikeio` `Dataset` or transformed into a `pandas` DataFrame, you'll often need to select specific parts of it. This might involve focusing on particular items (variables) or isolating data within specific time periods. Recall from Module 1 that `pandas` offers powerful ways to select data from DataFrames, such as selecting columns by name (e.g., `df['column_name']` or `df[['col1', 'col2']]`) or rows by index label (e.g., `df.loc['timestamp']`). We will build upon these fundamentals, concentrating on time series specific selections.

## Selecting Specific Items (Columns)

You can choose which time series items you want to work with either when you initially read the `dfs0` file using `mikeio` or after you've loaded the entire dataset into a `pandas` DataFrame.

*   **During `mikeio.read()`:**
    The `mikeio.read()` function provides an `items` argument, allowing you to specify which items to load by their names or their numerical indices (starting from 0). This can be particularly memory-efficient if you're dealing with large `dfs0` files and only need a small subset of the available items.

    For instance, to read only "Water Level" and "Discharge" from `data/sample.dfs0`:

    ```{python}
    import mikeio
    
    # Assuming "data/sample.dfs0" contains items named "Water Level" and "Discharge"
    ds_selected_names = mikeio.read("data/sample.dfs0", items=["Water Level", "Discharge"])
    ds_selected_names
    ```

    Alternatively, if you know "Water Level" is the first item (index 0) and "Discharge" is the third item (index 2):

    ```{python}
    # Assuming "data/sample.dfs0" has at least 3 items
    ds_selected_indices = mikeio.read("data/sample.dfs0", items=[0, 2])
    ds_selected_indices
    ```

*   **From a Pandas DataFrame:**
    If you've already loaded your data into a `pandas` DataFrame, you can use standard DataFrame column selection techniques.

    To select a single item, say "Water Level", which becomes a `pandas` Series:

    ```{python}
    # First, load the full dataset and convert to DataFrame
    ds_full = mikeio.read("data/sample.dfs0")
    df = ds_full.to_dataframe()
    
    # Select a single column
    water_level_series = df["Water Level"]
    water_level_series.head()
    ```

    To select multiple items, such as "Water Level" and "Rainfall", resulting in a new DataFrame:

    ```{python}
    # Select multiple columns
    selected_df = df[["Water Level", "Rainfall"]]
    selected_df.head()
    ```

## Selecting Specific Time Steps or Ranges

Similarly, you can filter your time series data for particular time periods, either at the point of reading the file or from an existing `pandas` DataFrame.

*   **During `mikeio.read()`:**
    The `mikeio.read()` function accepts a `time` argument. You can provide a start and end datetime string (e.g., `"YYYY-MM-DD/YYYY-MM-DD"`) or a Python `slice` object to specify the desired time window.

    To read data only for January 2023:

    ```{python}
    ds_time_selection = mikeio.read("data/sample.dfs0", time="2023-01-01/2023-01-31")
    ds_time_selection
    ```

*   **From a Pandas DataFrame (with `DatetimeIndex`):**
    `pandas` truly shines when selecting time-based data, provided your DataFrame has a `DatetimeIndex` (which `mikeio` sets up for you when converting to a DataFrame).
    *   **Slicing by date strings:** You can easily slice the DataFrame using date strings.

        To select data from March 1st, 2023, to March 7th, 2023:

        ```{python}
        # Assuming df is already loaded and covers this period
        df_date_slice = df["2023-03-01":"2023-03-07"]
        df_date_slice.head()
        ```

    *   **Partial string indexing:** `pandas` also allows for convenient partial string indexing. For example, you can select all data for a specific year or a specific month within a year.

        To get all data for the year 2022:

        ```{python}
        # Assuming df is already loaded and covers this period
        df_year_slice = df["2022"]
        df_year_slice.head()
        ```

        And for February 2023:

        ```{python}
        # Assuming df is already loaded and covers this period
        df_month_slice = df["2023-02"]
        df_month_slice.head()
        ```

::: {.callout-note}
## Efficiency and Workflow
Selecting data during the `mikeio.read()` operation can be more memory-efficient for very large `dfs0` files, as it avoids loading unnecessary data into memory. However, selecting from a `pandas` DataFrame offers more flexibility and the power of `pandas` indexing once the data is loaded. Choose the approach that best suits your needs and the size of your data. For exploration, loading more data into a DataFrame might be convenient, while for production scripts on large files, pre-selecting with `mikeio.read()` is often preferable.
:::

For more advanced selection techniques and a deeper dive into time series functionalities in `pandas`, refer to the official [Pandas documentation on Time Series / Date functionality](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html).