# Selecting Time Series Data

## Introduction
- Often, you don't need all the data from a *.dfs0* file. You might be interested in:
    - Specific items (e.g., only rainfall, not temperature).
    - Data within a particular time range (e.g., a specific storm event).
- *mikeio* allows selection during the read process, and *pandas* offers powerful selection capabilities on DataFrames.

## Selecting Items with `mikeio`
- You can specify which items to read using the `items` argument in `mikeio.read()`.
- You can provide item names (strings) or item indices (integers).
  ```python
  import mikeio

  dfs0_file = "data/multi_item.dfs0" # Assume this file has 'Rainfall' and 'Temperature'

  # Read only the 'Rainfall' item by name
  ds_rain = mikeio.read(dfs0_file, items=["Rainfall"])
  df_rain = ds_rain.to_dataframe()
  print("Rainfall data:")
  print(df_rain.head())

  # Read the first item by index (0-based)
  ds_first_item = mikeio.read(dfs0_file, items=[0])
  df_first_item = ds_first_item.to_dataframe()
  print("\nFirst item data:")
  print(df_first_item.head())
  ```
- This can be more memory-efficient if you only need a subset of large files.

## Selecting Time Periods with `mikeio`
- *mikeio* can also select data based on time steps or a time range during reading.
- **By time steps (indices):**
  ```python
  # Read only the first 10 time steps
  # dfs0_file would be defined as in the previous example
  ds_first_10_steps = mikeio.read(dfs0_file, time_steps=slice(0, 10)) # or list(range(10))
  df_first_10_steps = ds_first_10_steps.to_dataframe()
  # print(df_first_10_steps) # To see the result
  ```
- **By time range (using strings or `datetime` objects):**
  ```python
  import mikeio
  from datetime import datetime

  dfs0_file = "data/rainfall_long.dfs0" # Assume a longer time series

  # Read data for a specific date range (strings)
  ds_period_str = mikeio.read(dfs0_file, start_time="2023-01-15", end_time="2023-01-16")
  df_period_str = ds_period_str.to_dataframe()
  print("\nData for 2023-01-15 to 2023-01-16 (string-based):")
  print(df_period_str)

  # Read data using datetime objects (more precise)
  start_dt = datetime(2023, 1, 15, 12, 0, 0) # Year, Month, Day, Hour, Minute, Second
  end_dt = datetime(2023, 1, 15, 18, 0, 0)
  ds_period_dt = mikeio.read(dfs0_file, start_time=start_dt, end_time=end_dt)
  df_period_dt = ds_period_dt.to_dataframe()
  print("\nData from 2023-01-15 12:00 to 18:00 (datetime-based):")
  print(df_period_dt)
  ```

::: {.callout-note}
## Time Zones in `mikeio`
Be mindful of time zones. If your *.dfs0* file has time zone information, *mikeio* will attempt to handle it. *pandas* `DatetimeIndex` can also be time zone aware or naive. Consistency is key. Refer to *mikeio* and *pandas* documentation for advanced time zone handling.
For most MIKE+ files, timestamps are typically local time without explicit UTC offsets.
:::

## Selecting Data with `pandas`
- Once your data is in a *pandas* DataFrame (as covered in Module 1 and the previous section "Reading *.dfs0* Files with `mikeio`"), you can use its powerful selection methods.
- **Selecting columns (items):**
  ```python
  # ds would be a Dataset object from mikeio.read("data/multi_item.dfs0")
  # For example: ds = mikeio.read("data/multi_item.dfs0")
  df = ds.to_dataframe() # Assuming ds is read from a multi-item dfs0

  # Column names in the DataFrame typically match item names from the .dfs0 file.
  # Select a single column (returns a pandas Series)
  rain_series = df["Rainfall"]

  # Select multiple columns (returns a new pandas DataFrame)
  subset_df = df[["Rainfall", "Temperature"]]
  ```
- **Selecting rows by `DatetimeIndex` (time periods):**
  - *pandas* excels at time series slicing when the DataFrame has a `DatetimeIndex`.
  ```python
  # Assuming df has a DatetimeIndex, e.g., from ds.to_dataframe()
  # Select data for a specific date
  df_specific_date = df["2023-01-15"]

  # Select data for a date range
  df_date_range = df["2023-01-15":"2023-01-17"] # Includes end date

  # Select data for a specific date and time range
  df_datetime_range = df["2023-01-15 08:00:00":"2023-01-15 12:00:00"]
  ```
- **Using `.loc` for label-based selection (recommended for clarity):**
  - The `.loc` indexer is powerful for selecting rows and columns by their labels.
  ```python
  # Assuming df has a DatetimeIndex and columns "Rainfall", "Temperature"
  # Select rows by date range and specific columns
  df_loc_selection = df.loc["2023-01-15":"2023-01-16", ["Rainfall", "Temperature"]]
  ```

::: {.callout-tip}
## `mikeio` vs. `pandas` Selection
- **`mikeio` selection (on read):** Good for memory efficiency when dealing with very large files and you only need a small subset of items or a shorter time period. This reads less data into memory from the start.
- **`pandas` selection (on DataFrame):** More flexible and powerful for interactive analysis once the relevant data is loaded into memory. *pandas* offers a wider array of selection and manipulation tools.
- Often, you might use *mikeio* for an initial broad selection (e.g., specific items or a rough time period from a very large file) and then use *pandas* for finer-grained selections and analysis on the resulting DataFrame.
:::

## Video - Examples of Selecting Data with `mikeio` and `pandas` (5-10 min)
- This video demonstrates selecting items and time periods using both *mikeio* (during the read operation) and *pandas* (on an existing DataFrame).
- It will highlight the syntax and show practical examples to solidify your understanding.
- Example data files:
    - `[sample_multi_item.dfs0](data/sample_multi_item.dfs0){download="sample_multi_item.dfs0"}` (Example file with multiple data items)
    - `[sample_long_timeseries.dfs0](data/sample_long_timeseries.dfs0){download="sample_long_timeseries.dfs0"}` (Example file with a longer time record)
- {{< video URL_TO_SELECTING_DATA_VIDEO >}}